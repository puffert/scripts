import sys
import pykd
import argparse

def bold_text(text):
    return f"\033[1m{text}\033[0m"

def hex_byte(byte_str):
    if byte_str == "??":
        return byte_str

    try:
        val = int(byte_str, 16)
        if 0 <= val <= 255:
            return val
        else:
            raise ValueError
    except ValueError:
        raise argparse.ArgumentTypeError(
            f"only *hex* bytes between 00 and ff are valid, found {byte_str}"
        )

class Memdump:
    def __init__(self, line):
        self.__bytes = list()
        self.__address = ""
        self._parse_line(line)

    @property
    def bytes(self):
        return self.__bytes

    @bytes.setter
    def bytes(self, val: str):
        self.__bytes = [hex_byte(x) for x in val.split()]

    @property
    def address(self):
        return self.__address

    @address.setter
    def address(self, val: str):
        self.__address = val

    def _parse_line(self, line):
        parts = line.split("  ")[:2]

        if len(parts) == 0:
            return

        self.address = parts[0]
        bytes_str = ""

        for i, byte in enumerate(parts[1].split()):
            if i == 7:
                bytes_str += " ".join(byte.split("-")) + " "
                continue
            bytes_str += f"{byte} "

        self.bytes = bytes_str

    def __str__(self):
        byte_str = ""
        for byte in self.bytes:
            if byte == "??":
                byte_str += f"{byte} "
            else:
                byte_str += f"{byte:02X} "

        return f"{self.address}  {byte_str}"

def find_bad_chars(args):
    chars = bytes(i for i in range(args.start, args.end + 1) if i not in args.bad)

    command = f"db {args.address} L 0n{len(chars)}"
    result = pykd.dbgCommand(command)

    if result is None:
        print(f"[!] Ran '{command}', but received no output; exiting...")
        raise SystemExit

    char_counter = 0
    bad_chars = []
    buffer_size = 0

    for line in result.splitlines():
        memdump = Memdump(line)
        print(memdump)
        print(" " * 10, end="")

        for byte in memdump.bytes:
            if byte == chars[char_counter]:
                print(f"{byte:02X}", end=" ")
            else:
                print(bold_text("--"), end=" ")
                bad_chars.append(byte)

            char_counter += 1
            buffer_size += 1

        print()

    if buffer_size < len(chars):
        print("\n[!] The entire payload does not fit in the buffer.")
        print(f"    Buffer size: {buffer_size}, Payload size: {len(chars)}")
        print("    You may need to send the payload in multiple parts.\n")

    print(bold_text("Bad characters found:"), ", ".join(f"\\x{b:02x}" for b in bad_chars))

    new_payload = ''.join(f'\\x{i:02x}' for i in range(args.start, args.end + 1) if i not in args.bad and i not in bad_chars)
    print("\nNew payload without bad characters:")
    print(new_payload)

    print("\n[+] Examples and help for common issues with badchars and smaller buffer than payload")
    print("    1. Split the payload into smaller parts and send them separately.")
    print("    2. Use a different encoding technique or a custom encoder.")
    print("    3. Utilize an egghunter to find the payload in memory.")
    print("    4. Identify and use a different memory space with fewer constraints.")
    print("\n[+] Steps to find all bad characters:")
    print("    1. Generate a payload without known bad characters.")
    print("    2. Send the payload to the target application.")
    print("    3. Compare the payload in memory with the original payload.")
    print("    4. Identify and remove bad characters from the payload.")
    print("    5. Repeat steps 1-4 until all bad characters are found.")

def generate_byte_string(args):
    known_bad = ", ".join(f'{x:02X}' for x in args.bad)
    var_str = f"chars = bytes(i for i in range({args.start}, {args.end + 1}) if i not in [{known_bad}])"
    print("[+] Characters as a range of bytes")
    print(var_str, end="\n\n")

    print("[+] Characters as a byte string")
    counter = 0

    for i in range(args.start, args.end + 1):
        if i in args.bad:
            continue

        if i == args.start:
            print(f"chars  = b'\\x{i:02X}", end="")
        elif counter % 16 == 0:
            print("'")
            print(f"chars += b'\\x{i:02X}", end="")
        else:
            print(f"\\x{i:02X}", end="")

        counter += 1

    if counter % 16 != 0 and counter != 0:
        print("'")

def main(args):
    if args.address is not None:
        find_bad_chars(args)
    else:
        generate_byte_string(args)

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-s",
        "--start",
        help="hex byte from which to start searching in memory (default: 00)",
        default=0,
        type=hex_byte,
    )
    parser.add_argument(
        "-e",
        "--end",
        help="last hex byte to search for in memory (default: ff)",
        default=255,
        type=hex_byte,
    )
    parser.add_argument(
        "-b",
        "--bad",
        help="space separated list of hex bytes that are already known bad (ex: -b 00 0a 0d)",
        nargs="+",
        type=hex_byte,
        default=[],
    )

    mutuals = parser.add_mutually_exclusive_group(required=True)
    mutuals.add_argument(
        "-a", "--address", help="address from which to begin character comparison"
    )
    mutuals.add_argument(
        "-g",
        "--generate",
        help="generate a byte string suitable for use in source code",
        action="store_true",
    )

    parsed = parser.parse_args()

    if parsed.start > parsed.end:
        print("[!] --start value must be higher than --end; exiting...")
        raise SystemExit

    main(parsed)

