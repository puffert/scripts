import sys
import re
import argparse

def process_asm_file(file_path):
    try:
        with open(file_path, 'r') as file:
            asm_lines = file.readlines()
    except FileNotFoundError:
        print(f'Error: File not found at {file_path}')
        sys.exit(1)
    except Exception as e:
        print(f'Error: {e}')
        sys.exit(1)

    for line in asm_lines:
        if line.strip().endswith('ret'):
            process_asm_line(line.strip())

def process_asm_line(line):
    """Processes a single assembly line containing a 'ret' instruction."""
    if 'push esp' in line:
        if has_same_push_esp_value_after_ret(line):
            print(f'Marked Line: {line}')

def has_same_push_esp_value_after_ret(line):
    """
    Checks if the original value of ESP is saved in another register after the 'ret' instruction
    in the given assembly line.
    """
    instructions = re.split(r'\s*;\s*', line)
    stack_changes = 0
    esp_moved_to_register = False
    push_esp_index = None
    stack_depth = 0

    for idx, inst in enumerate(instructions):
        if 'push' in inst:
            if 'esp' in inst:
                push_esp_index = idx
            stack_changes -= 4
            stack_depth += 1
        elif 'pop' in inst:
            if 'popfd' not in inst:  # Ignore 'popfd' as it does not store ESP in a register
                stack_changes += 4
                stack_depth -= 1
                if push_esp_index is not None and idx > push_esp_index and stack_depth == 0:
                    esp_moved_to_register = True
        elif 'add esp' in inst:
            stack_changes += int(re.split(r'\s*,\s*', inst)[1].strip(), 0)
        elif 'sub esp' in inst:
            stack_changes -= int(re.split(r'\s*,\s*', inst)[1].strip(), 0)
        elif ('mov' in inst and 'esp' in inst) or ('lea' in inst and '[esp]' in inst):
            esp_moved_to_register = True

    return stack_changes == 0 and esp_moved_to_register





def parse_arguments():
    """Parses command-line arguments."""
    parser = argparse.ArgumentParser(description='Analyze assembly code to find lines with same ESP value after ret.')
    parser.add_argument('input_file', help='Path to the input assembly file.')

    return parser.parse_args()

if __name__ == '__main__':
    args = parse_arguments()
    process_asm_file(args.input_file)
