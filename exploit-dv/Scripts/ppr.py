import pykd
import argparse
from enum import Enum, auto
import textwrap

def hex_byte(byte_str):
    """validate user input is a hex representation of an int between 0 and 255 inclusive"""
    if byte_str == "??":
        # windbg shows ?? when it can't access a memory region, but we shouldn't stop execution because of it
        return byte_str

    try:
        val = int(byte_str, 16)
        if 0 <= val <= 255:
            return val
        else:
            raise ValueError
    except ValueError:
        raise argparse.ArgumentTypeError(
            f"only *hex* bytes between 00 and ff are valid, found {byte_str}"
        )


class Module:
    # 00400000 00465000   diskpls    (deferred)
    def __init__(self, unparsed):
        self.name = "unknown"
        self.start = -1
        self.end = -1
        self.unparsed = unparsed.split()
        self.parse()

    def parse(self):
        if len(self.unparsed) >= 3:
            self.start = self.unparsed[0]
            self.end = self.unparsed[1]
            self.name = self.unparsed[2]

    def __str__(self):
        return f"{self.name}(start={self.start}, end={self.end})"


class PopR32(Enum):
    eax = 0x58
    ecx = auto()
    edx = auto()
    ebx = auto()
    esp = auto()
    esi = auto()
    edi = auto()


def checkBadChars(bAddr, badChars):
    for i in bAddr:
        if i in badChars:
            return "--"
    return "OK"

def display_stats(mod_gadget_count, total_gadgets, bad_chars):
    print("\n---- STATS ----")
    print(">> BADCHARS: ", end="")
    for i in bad_chars:
        print("\\x{:02X}".format(i), end="")
    print()
    print(f">> Usable Gadgets Found: {total_gadgets}")
    print(">> Module Gadget Counts")
    for m, c in mod_gadget_count.items():
        print("   - {}: {} ".format(m, c))


def main(args):
    modules = pykd.dbgCommand("lm")
    total_gadgets = 0
    mod_gadget_count = {}

    for mod_line in modules.splitlines():
        module = Module(mod_line)

        if module.name.lower() not in [mod.lower() for mod in args.modules]:
            continue

        num_gadgets = 0
        print(f"[+] Searching {module.name} for pop r32; pop r32; ret")
        print("[+] BADCHARS: ", end="")
        for i in args.bad:
            print("\\x{:02X}".format(i), end="")
        print()

        for pop1 in range(0x58, 0x60):
            for pop2 in range(0x58, 0x60):
                command = (
                    f"s-[1]b {module.start} {module.end} {hex(pop1)} {hex(pop2)} c3"
                )
                result = pykd.dbgCommand(command)

                if result is None:
                    continue

                for addr in result.splitlines():
                    try:
                        b_addr = int(addr, 16).to_bytes(4, "little")
                        bc_chk = check_bad_chars(b_addr, args.bad)
                        b_addr_esc = "".join(f"\\x{b:02X}" for b in b_addr)

                        if args.showbc and bc_chk == "--":
                            print(
                                f"[{bc_chk}] {module.name}::{addr}: pop {PopR32(pop1).name}; pop {PopR32(pop2).name}; ret ; {b_addr_esc}"
                            )
                        elif bc_chk == "OK":
                            print(
                                f"[{bc_chk}] {module.name}::{addr}: pop {PopR32(pop1).name}; pop {PopR32(pop2).name}; ret ; {b_addr_esc}"
                            )
                            num_gadgets += 1
                    except ValueError:
                        pass

        print(f"[+] {module.name}: Found {num_gadgets} usable gadgets!")
        mod_gadget_count[module.name] = num_gadgets
        total_gadgets += num_gadgets

    display_stats(mod_gadget_count, total_gadgets, args.bad)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-s",
        "--showbc",
        help="Show addresses with bad chars",
        action="store_true"
    )
    parser.add_argument(
        "-b",
        "--bad",
        help="space separated list of hex bytes that are already known bad (ex: -b 00 0a 0d)",
        nargs="+",
        type=hex_byte,
        default=[],
    )
    parser.add_argument(
        "-m",
        "--modules",
        help="module name(s) to search for pop pop ret (ex: find-ppr.py libspp diskpls libpal)",
        required=True,
        nargs="+",
    )
    args = parser.parse_args()
    main(args)
    print("Done!")
